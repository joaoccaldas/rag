/**
 * Enhanced Visual Content Manager
 * Handles both file system and localStorage storage with automatic fallback
 */

import { VisualContent } from '../rag/types'

interface VisualContentManager {
  storeVisualContent(visuals: VisualContent[]): Promise<VisualContent[]>
  getVisualContent(): Promise<VisualContent[]>
  ensureVisualContentAccess(content: VisualContent): Promise<VisualContent>
}

class EnhancedVisualContentManager implements VisualContentManager {
  private readonly STORAGE_KEY = 'rag_visual_content_enhanced'
  
  /**
   * Store visual content with smart storage selection
   */
  async storeVisualContent(visuals: VisualContent[]): Promise<VisualContent[]> {
    const processedVisuals: VisualContent[] = []
    
    for (const visual of visuals) {
      try {
        // Only try file system storage on server side
        if (typeof window === 'undefined') {
          try {
            const { storeVisualContentToFiles } = await import('../rag/utils/file-system-visual-storage')
            await storeVisualContentToFiles([visual])
            
            // If successful, convert to API URLs
            const processedVisual = this.convertToFileSystemUrls(visual)
            processedVisuals.push(processedVisual)
          } catch (fileSystemError) {
            console.warn(`File system storage failed for ${visual.id}, using localStorage:`, fileSystemError)
            
            // Fallback to localStorage with data URLs intact
            const processedVisual = this.ensureDataUrls(visual)
            processedVisuals.push(processedVisual)
          }
        } else {
          // Client side - use localStorage only
          const processedVisual = this.ensureDataUrls(visual)
          processedVisuals.push(processedVisual)
        }
      } catch (error) {
        console.error(`Failed to process visual content ${visual.id}:`, error)
        // Add the visual as-is if all else fails
        processedVisuals.push(visual)
      }
    }
    
    // Store metadata about storage method
    this.updateStorageMetadata(processedVisuals)
    
    return processedVisuals
  }
  
  /**
   * Convert visual content to use file system API URLs
   */
  private convertToFileSystemUrls(visual: VisualContent): VisualContent {
    const processed = { ...visual }
    
    // Generate API URLs based on file names
    if (visual.id) {
      // These URLs will be generated by the file system storage
      processed.source = `/api/visual-content/image/${visual.id}_image.png`
      processed.thumbnail = `/api/visual-content/thumbnail/${visual.id}_thumb.png`
    }
    
    return processed
  }
  
  /**
   * Ensure visual content has data URLs for localStorage fallback
   */
  private ensureDataUrls(visual: VisualContent): VisualContent {
    const processed = { ...visual }
    
    // Keep original data URLs if available
    if (visual.data?.base64 && !processed.source) {
      processed.source = visual.data.base64
    }
    
    if (visual.thumbnail && visual.thumbnail.startsWith('data:')) {
      // Keep thumbnail as-is
    }
    
    return processed
  }
  
  /**
   * Get visual content from storage
   */
  async getVisualContent(): Promise<VisualContent[]> {
    try {
      // Only try file system storage on server side
      if (typeof window === 'undefined') {
        try {
          const { getVisualContentFromFiles } = await import('../rag/utils/file-system-visual-storage')
          const fileSystemContent = await getVisualContentFromFiles()
          
          if (fileSystemContent && fileSystemContent.length > 0) {
            return fileSystemContent
          }
        } catch (error) {
          console.warn('File system retrieval failed:', error)
        }
      }
    } catch (error) {
      console.warn('File system check failed:', error)
    }
    
    // Fallback to localStorage
    try {
      const { getStoredVisualContent } = await import('../rag/utils/visual-content-storage')
      return await getStoredVisualContent()
    } catch (error) {
      console.error('All storage retrieval methods failed:', error)
      return []
    }
  }
  
  /**
   * Ensure a specific visual content item can be accessed
   */
  async ensureVisualContentAccess(content: VisualContent): Promise<VisualContent> {
    // If it's already a data URL, it should work
    if (content.source?.startsWith('data:') || content.thumbnail?.startsWith('data:')) {
      return content
    }
    
    // If it's an API URL, test if it's accessible
    if (content.source?.startsWith('/api/') || content.thumbnail?.startsWith('/api/')) {
      try {
        // Test if API endpoint responds
        const testUrl = content.thumbnail || content.source
        if (testUrl) {
          const response = await fetch(testUrl, { method: 'HEAD' })
          if (response.ok) {
            return content // API URLs work
          }
        }
      } catch (apiError) {
        console.warn('API URL not accessible:', apiError)
      }
      
      // API URLs failed, try to get from localStorage
      return this.recoverFromLocalStorage(content)
    }
    
    return content
  }
  
  /**
   * Recover visual content from localStorage when API fails
   */
  private async recoverFromLocalStorage(content: VisualContent): Promise<VisualContent> {
    try {
      const { getStoredVisualContent } = await import('../rag/utils/visual-content-storage')
      const allStored = await getStoredVisualContent()
      
      const matching = allStored.find(stored => stored.id === content.id)
      if (matching) {
        console.log('ðŸ”„ Recovered visual content from localStorage:', content.id)
        return matching
      }
    } catch (error) {
      console.error('Failed to recover from localStorage:', error)
    }
    
    return content
  }
  
  /**
   * Update storage metadata for debugging
   */
  private updateStorageMetadata(visuals: VisualContent[]): void {
    try {
      const metadata = {
        lastUpdated: new Date().toISOString(),
        totalItems: visuals.length,
        storageTypes: visuals.map(v => ({
          id: v.id,
          hasApiUrl: v.source?.startsWith('/api/') || v.thumbnail?.startsWith('/api/'),
          hasDataUrl: v.source?.startsWith('data:') || v.thumbnail?.startsWith('data:')
        }))
      }
      
      localStorage.setItem(`${this.STORAGE_KEY}_metadata`, JSON.stringify(metadata))
    } catch (error) {
      console.warn('Failed to update storage metadata:', error)
    }
  }
}

export const visualContentManager = new EnhancedVisualContentManager()
export default visualContentManager
